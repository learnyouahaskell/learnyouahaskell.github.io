<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "https://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Starting Out - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<base href="">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="assets/images/favicon.png" type="image/png">
        <link rel="prev" href="introduction.html">
        <link rel="next" href="types-and-typeclasses.html">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction.html" class="prevlink">Introduction</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses.html" class="nxtlink">Types and Typeclasses</a>
                                            </li>
                </ul>
            </div>
<h1 style="margin-left:-3px" id="starting-out">Starting Out</h1>
<h2 id="ready-set-go">Ready, set, go!</h2>
<p><img src="assets/images/starting-out/startingout.png" class="right"
width="214" height="187" alt="egg" /> Alright, let’s get started! If
you’re the sort of horrible person who doesn’t read introductions to
things and you skipped it, you might want to read the last section in
the introduction anyway because it explains what you need to follow this
tutorial and how we’re going to load functions. The first thing we’re
going to do is run ghc’s interactive mode and call some function to get
a very basic feel for Haskell. Open your terminal and type in
<code>ghci</code>. You will be greeted with something like this.</p>
<pre class="haskell: ghci"><code>GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
ghci&gt;</code></pre>
<p>Congratulations, you’re in GHCI!</p>
<p>Here’s some simple arithmetic.</p>
<pre class="haskell: ghci"><code>ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;</code></pre>
<p>This is pretty self-explanatory. We can also use several operators on
one line and all the usual precedence rules are obeyed. We can use
parentheses to make the precedence explicit or to change it.</p>
<pre class="haskell: ghci"><code>ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950</code></pre>
<p>Pretty cool, huh? Yeah, I know it’s not but bear with me. A little
pitfall to watch out for here is negating numbers. If we want to have a
negative number, it’s always best to surround it with parentheses. Doing
<code>5 * -3</code> will make GHCI yell at you but doing
<code>5 * (-3)</code> will work just fine.</p>
<p>Boolean algebra is also pretty straightforward. As you probably know,
<code>&amp;&amp;</code> means a boolean <em>and</em>, <code>||</code>
means a boolean <em>or</em>. <code>not</code> negates a
<code>True</code> or a <code>False</code>.</p>
<pre class="haskell: ghci"><code>ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False</code></pre>
<p>Testing for equality is done like so.</p>
<pre class="haskell: ghci"><code>ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; &quot;hello&quot; == &quot;hello&quot;
True</code></pre>
<p>What about doing <code>5 + "llama"</code> or <code>5 == True</code>?
Well, if we try the first snippet, we get a big scary error message!</p>
<pre class="haskell: ghci"><code>&lt;interactive&gt;:1:1: error: [GHC-39999]
    • No instance for ‘Num String’ arising from the literal ‘5’
    • In the first argument of ‘(+)’, namely ‘5’
      In the expression: 5 + &quot;llama&quot;
      In an equation for ‘it’: it = 5 + &quot;llama&quot;</code></pre>
<p>Yikes! What GHCI is telling us here is that <code>"llama"</code> is
not a number and so it doesn’t know how to add it to 5. Even if it
wasn’t <code>"llama"</code> but <code>"four"</code> or <code>"4"</code>,
Haskell still wouldn’t consider it to be a number. <code>+</code>
expects its left and right side to be numbers. If we tried to do
<code>True == 5</code>, GHCI would tell us that the types don’t match.
Whereas <code>+</code> works only on things that are considered numbers,
<code>==</code> works on any two things that can be compared. But the
catch is that they both have to be the same type of thing. You can’t
compare apples and oranges. We’ll take a closer look at types a bit
later. Note: you can do <code>5 + 4.0</code> because <code>5</code> is
sneaky and can act like an integer or a floating-point number.
<code>4.0</code> can’t act like an integer, so <code>5</code> is the one
that has to adapt.</p>
<div class="hintbox">
<p><strong>Note:</strong> GHC errors are all assigned unique identifiers
such as <code>GHC-39999</code> above. Whenever you are stuck with a
stubborn error, you can look it up at <a
href="https://errors.haskell.org/">https://errors.haskell.org/</a> to
learn typical causes and solutions.</p>
</div>
<p>You may not have known it but we’ve been using functions now all
along. For instance, <code>*</code> is a function that takes two numbers
and multiplies them. As you’ve seen, we call it by sandwiching it
between them. This is what we call an <em>infix</em> function. Most
functions that aren’t used with numbers are <em>prefix</em> functions.
Let’s take a look at them.</p>
<p><img src="assets/images/starting-out/ringring.png" class="right"
width="160" height="161" alt="phoen" /> Functions are usually prefix, so
from now on we won’t explicitly state that a function is of the prefix
form, we’ll just assume it. In most imperative languages, functions are
called by writing the function name and then writing its parameters in
parentheses, usually separated by commas. In Haskell, functions are
called by writing the function name, a space and then the parameters,
separated by spaces. For a start, we’ll try calling one of the most
boring functions in Haskell.</p>
<pre class="haskell: ghci"><code>ghci&gt; succ 8
9</code></pre>
<p>The <code>succ</code> function takes anything that has a defined
successor and returns that successor. As you can see, we just separate
the function name from the parameter with a space. Calling a function
with several parameters is also simple. The functions <code>min</code>
and <code>max</code> take two things that can be put in an order (like
integers!). <code>min</code> returns the one that’s lesser and
<code>max</code> returns the one that’s greater. See for yourself:</p>
<pre class="haskell: ghci"><code>ghci&gt; min 9 10
9
ghci&gt; max 100 101
101</code></pre>
<p>Function application (calling a function by putting a space after it
and then typing out the parameters) has the highest precedence of them
all. What that means for us is that these two statements are
equivalent.</p>
<pre class="haskell: ghci"><code>ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16</code></pre>
<p>However, if we wanted to get the successor of the product of numbers
9 and 10, we couldn’t write <code>succ 9 * 10</code> because that would
get the successor of 9, which would then be multiplied by 10. So 100.
We’d have to write <code>succ (9 * 10)</code> to get 91.</p>
<p>If a function takes two parameters, we can also call it as an infix
function by surrounding it with backticks. For instance, the
<code>div</code> function takes two integers and does integral division
between them. Doing <code>div 92 10</code> results in a 9. But when we
call it like that, there may be some confusion as to which number is
doing the division and which one is being divided. So we can call it as
an infix function by doing <code>92 `div` 10</code> and suddenly it’s
much clearer.</p>
<p>Lots of people who come from imperative languages tend to stick to
the notion that parentheses should denote function application. For
example, in C, you use parentheses to call functions like
<code>foo()</code>, <code>bar(1)</code> or <code>baz(3, "haha")</code>.
Like we said, spaces are used for function application in Haskell. So
those functions in Haskell would be <code>foo</code>, <code>bar 1</code>
and <code>baz 3 "haha"</code>. So if you see something like
<code>bar (bar 3)</code>, it doesn’t mean that <code>bar</code> is
called with <code>bar</code> and <code>3</code> as parameters. It means
that we first call the function <code>bar</code> with <code>3</code> as
the parameter to get some number and then we call <code>bar</code> again
with that number. In C, that would be something like
<code>bar(bar(3))</code>.</p>
<h2 id="babys-first-functions">Baby’s first functions</h2>
<p>In the previous section we got a basic feel for calling functions.
Now let’s try making our own! Open up your favorite text editor and
punch in this function that takes a number and multiplies it by two.</p>
<pre class="haskell: hs"><code>doubleMe x = x + x</code></pre>
<p>Functions are defined in a similar way that they are called. The
function name is followed by parameters separated by spaces. But when
defining functions, there’s a <code>=</code> and after that we define
what the function does. Save this as <code>baby.hs</code> or something.
Now navigate to where it’s saved and run <code>ghci</code> from there.
Once inside GHCI, do <code>:l baby</code>. Now that our script is
loaded, we can play with the function that we defined.</p>
<pre class="haskell: ghci"><code>ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, one module loaded.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6</code></pre>
<p>Because <code>+</code> works on integers as well as on floating-point
numbers (anything that can be considered a number, really), our function
also works on any number. Let’s make a function that takes two numbers
and multiplies each by two and then adds them together.</p>
<pre class="haskell: hs"><code>doubleUs x y = x*2 + y*2</code></pre>
<p>Simple. We could have also defined it as
<code>doubleUs x y = x + x + y + y</code>. Testing it out produces
pretty predictable results (remember to append this function to the
<code>baby.hs</code> file, save it and then do <code>:l baby</code>
inside GHCI).</p>
<pre class="haskell: ghci"><code>ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478</code></pre>
<p>As expected, you can call your own functions from other functions
that you made. With that in mind, we could redefine
<code>doubleUs</code> like this:</p>
<pre class="haskell: hs"><code>doubleUs x y = doubleMe x + doubleMe y</code></pre>
<p>This is a very simple example of a common pattern you will see
throughout Haskell. Making basic functions that are obviously correct
and then combining them into more complex functions. This way you also
avoid repetition. What if some mathematicians figured out that 2 is
actually 3 and you had to change your program? You could just redefine
<code>doubleMe</code> to be <code>x + x + x</code> and since
<code>doubleUs</code> calls <code>doubleMe</code>, it would
automatically work in this strange new world where 2 is 3.</p>
<p>Functions in Haskell don’t have to be in any particular order, so it
doesn’t matter if you define <code>doubleMe</code> first and then
<code>doubleUs</code> or if you do it the other way around.</p>
<p>Now we’re going to make a function that multiplies a number by 2 but
only if that number is smaller than or equal to 100 because numbers
bigger than 100 are big enough as it is!</p>
<pre class="haskell: hs"><code>doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2</code></pre>
<p><img src="assets/images/starting-out/baby.png" class="left"
width="140" height="211" alt="this is you" /></p>
<p>Right here we introduced Haskell’s if statement. You’re probably
familiar with if statements from other languages. The difference between
Haskell’s if statement and if statements in imperative languages is that
the else part is mandatory in Haskell. In imperative languages you can
just skip a couple of steps if the condition isn’t satisfied but in
Haskell every expression and function must return something. We could
have also written that if statement in one line but I find this way more
readable. Another thing about the if statement in Haskell is that it is
an <em>expression</em>. An expression is basically a piece of code that
returns a value. <code>5</code> is an expression because it returns 5,
<code>4 + 8</code> is an expression, <code>x + y</code> is an expression
because it returns the sum of <code>x</code> and <code>y</code>. Because
the else is mandatory, an if statement will always return something and
that’s why it’s an expression. If we wanted to add one to every number
that’s produced in our previous function, we could have written its body
like this.</p>
<pre class="haskell: hs"><code>doubleSmallNumber&#39; x = (if x &gt; 100 then x else x*2) + 1</code></pre>
<p>Had we omitted the parentheses, it would have added one only if
<code>x</code> wasn’t greater than 100. Note the <code>'</code> at the
end of the function name. That apostrophe doesn’t have any special
meaning in Haskell’s syntax. It’s a valid character to use in a function
name. We usually use <code>'</code> to either denote a strict version of
a function (one that isn’t lazy) or a slightly modified version of a
function or a variable. Because <code>'</code> is a valid character in
functions, we can make a function like this.</p>
<pre class="haskell: hs"><code>conanO&#39;Brien = &quot;It&#39;s a-me, Conan O&#39;Brien!&quot;</code></pre>
<p>There are two noteworthy things here. The first is that in the
function name we didn’t capitalize Conan’s name. That’s because
functions can’t begin with uppercase letters. We’ll see why a bit later.
The second thing is that this function doesn’t take any parameters. When
a function doesn’t take any parameters, we usually say it’s a
<em>definition</em> (or a <em>name</em>). Because we can’t change what
names (and functions) mean once we’ve defined them,
<code>conanO'Brien</code> and the string
<code>"It's a-me, Conan O'Brien!"</code> can be used
interchangeably.</p>
<h2 id="an-intro-to-lists">An intro to lists</h2>
<p><img src="assets/images/starting-out/list.png" class="left"
width="150" height="103" alt="BUY A DOG" /> Much like shopping lists in
the real world, lists in Haskell are very useful. It’s the most used
data structure and it can be used in a multitude of different ways to
model and solve a whole bunch of problems. Lists are SO awesome. In this
section we’ll look at the basics of lists, strings (which are lists) and
list comprehensions.</p>
<p>In Haskell, lists are a <strong>homogenous</strong> data structure.
They store several elements of the same type. That means that we can
have a list of integers or a list of characters but we can’t have a list
that has a few integers and then a few characters. And now, a list!</p>
<pre class="haskell: ghci"><code>ghci&gt; lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]</code></pre>
<p>As you can see, lists are denoted by square brackets and the values
in the lists are separated by commas. If we tried a list like
<code>[1,2,'a',3,'b','c',4]</code>, Haskell would complain that
characters (which are, by the way, denoted as a character between single
quotes) are not numbers. Speaking of characters, strings are just lists
of characters. <code>"hello"</code> is just syntactic sugar for
<code>['h','e','l','l','o']</code>. Because strings are lists, we can
use list functions on them, which is really handy.</p>
<p>A common task is putting two lists together. This is done by using
the <code>++</code> operator.</p>
<pre class="haskell: ghci"><code>ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; &quot;hello&quot; ++ &quot; &quot; ++ &quot;world&quot;
&quot;hello world&quot;
ghci&gt; [&#39;w&#39;,&#39;o&#39;] ++ [&#39;o&#39;,&#39;t&#39;]
&quot;woot&quot;</code></pre>
<p>Watch out when repeatedly using the <code>++</code> operator on long
strings. When you put together two lists (even if you append a singleton
list to a list, for instance: <code>[1,2,3] ++ [4]</code>), internally,
Haskell has to walk through the whole list on the left side of
<code>++</code>. That’s not a problem when dealing with lists that
aren’t too big. But putting something at the end of a list that’s fifty
million entries long is going to take a while. However, putting
something at the beginning of a list using the <code>:</code> operator
(also called the cons operator) is instantaneous.</p>
<pre class="haskell: ghci"><code>ghci&gt; &#39;A&#39;:&quot; SMALL CAT&quot;
&quot;A SMALL CAT&quot;
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]</code></pre>
<p>Notice how <code>:</code> takes a number and a list of numbers or a
character and a list of characters, whereas <code>++</code> takes two
lists. Even if you’re adding an element to the end of a list with
<code>++</code>, you have to surround it with square brackets so it
becomes a list.</p>
<p><code>[1,2,3]</code> is actually just syntactic sugar for
<code>1:2:3:[]</code>. <code>[]</code> is an empty list. If we prepend
<code>3</code> to it, it becomes <code>[3]</code>. If we prepend
<code>2</code> to that, it becomes <code>[2,3]</code>, and so on.</p>
<div class="hintbox">
<p><strong>Note:</strong> <code>[]</code>, <code>[[]]</code>
and<code>[[],[],[]]</code> are all different things. The first one is an
empty list, the seconds one is a list that contains one empty list, the
third one is a list that contains three empty lists.</p>
</div>
<p>If you want to get an element out of a list by index, use
<code>!!</code>. The indices start at 0.</p>
<pre class="haskell: ghci"><code>ghci&gt; &quot;Steve Buscemi&quot; !! 6
&#39;B&#39;
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2</code></pre>
<p>But if you try to get the sixth element from a list that only has
four elements, you’ll get an error so be careful!</p>
<p>Lists can also contain lists. They can also contain lists that
contain lists that contain lists …</p>
<pre class="haskell: ghci"><code>ghci&gt; b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4]</code></pre>
<p>The lists within a list can be of different lengths but they can’t be
of different types. Just like you can’t have a list that has some
characters and some numbers, you can’t have a list that has some lists
of characters and some lists of numbers.</p>
<p>Lists can be compared if the stuff they contain can be compared. When
using <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and
<code>&gt;=</code> to compare lists, they are compared in
lexicographical order. First the heads are compared. If they are equal
then the second elements are compared, etc.</p>
<pre class="haskell: ghci"><code>ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True</code></pre>
<p>What else can you do with lists? Here are some basic functions that
operate on lists.</p>
<p><code class="label function">head</code> takes a list and returns its
head. The head of a list is basically its first element.</p>
<pre class="haskell: ghci"><code>ghci&gt; head [5,4,3,2,1]
5</code></pre>
<p><code class="label function">tail</code> takes a list and returns its
tail. In other words, it chops off a list’s head.</p>
<pre class="haskell: ghci"><code>ghci&gt; tail [5,4,3,2,1]
[4,3,2,1]</code></pre>
<p><code class="label function">last</code> takes a list and returns its
last element.</p>
<pre class="haskell: ghci"><code>ghci&gt; last [5,4,3,2,1]
1</code></pre>
<p><code class="label function">init</code> takes a list and returns
everything except its last element.</p>
<pre class="haskell: ghci"><code>ghci&gt; init [5,4,3,2,1]
[5,4,3,2]</code></pre>
<p>If we think of a list as a monster, here’s what’s what.</p>
<p><img src="assets/images/starting-out/listmonster.png" class="center"
width="580" height="290" alt="list monster" /></p>
<p>But what happens if we try to get the head of an empty list?</p>
<pre class="haskell: ghci"><code>ghci&gt; head []
*** Exception: Prelude.head: empty list</code></pre>
<p>Oh my! It all blows up in our face! If there’s no monster, it doesn’t
have a head. When using <code>head</code>, <code>tail</code>,
<code>last</code> and <code>init</code>, be careful not to use them on
empty lists. This error cannot be caught at compile time, so it’s always
good practice to take precautions against accidentally telling Haskell
to give you some elements from an empty list.</p>
<p><code class="label function">length</code> takes a list and returns
its length, obviously.</p>
<pre class="haskell: ghci"><code>ghci&gt; length [5,4,3,2,1]
5</code></pre>
<p><code class="label function">null</code> checks if a list is empty.
If it is, it returns <code>True</code>, otherwise it returns
<code>False</code>. Use this function instead of <code>xs == []</code>
(if you have a list called <code>xs</code>).</p>
<pre class="haskell: ghci"><code>ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</code></pre>
<p><code class="label function">reverse</code> reverses a list.</p>
<pre class="haskell: ghci"><code>ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</code></pre>
<p><code class="label function">take</code> takes a number and a list.
It extracts that many elements from the beginning of the list.
Watch.</p>
<pre class="haskell: ghci"><code>ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</code></pre>
<p>See how if we try to take more elements than there are in the list,
it just returns the list. If we try to take 0 elements, we get an empty
list.</p>
<p><code class="label function">drop</code> works in a similar way, only
it drops the number of elements from the beginning of a list.</p>
<pre class="haskell: ghci"><code>ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[]</code></pre>
<p><code class="label function">maximum</code> takes a list of stuff
that can be put in some kind of order and returns the biggest
element.</p>
<p><code class="label function">minimum</code> returns the smallest.</p>
<pre class="haskell: ghci"><code>ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9</code></pre>
<p><code class="label function">sum</code> takes a list of numbers and
returns their sum.</p>
<p><code class="label function">product</code> takes a list of numbers
and returns their product.</p>
<pre class="haskell: ghci"><code>ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0</code></pre>
<p><code class="label function">elem</code> takes a thing and a list of
things and tells us if that thing is an element of the list. It’s
usually called as an infix function because it’s easier to read that
way.</p>
<pre class="haskell: ghci"><code>ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False</code></pre>
<p>Those were a few basic functions that operate on lists. We’ll take a
look at more list functions <a
href="modules.html#data-list">later</a>.</p>
<h2 id="texas-ranges">Texas ranges</h2>
<p><img src="assets/images/starting-out/cowboy.png" class="right"
width="200" height="258" alt="draw" /> What if we want a list of all
numbers between 1 and 20? Sure, we could just type them all out but
obviously that’s not a solution for gentlemen who demand excellence from
their programming languages. Instead, we’ll use ranges. Ranges are a way
of making lists that are arithmetic sequences of elements that can be
enumerated. Numbers can be enumerated. One, two, three, four, etc.
Characters can also be enumerated. The alphabet is an enumeration of
characters from A to Z. Names can’t be enumerated. What comes after
“John”? I don’t know.</p>
<p>To make a list containing all the natural numbers from 1 to 20, you
just write <code>[1..20]</code>. That is the equivalent of writing
<code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code> and
there’s no difference between writing one or the other except that
writing out long enumeration sequences manually is stupid.</p>
<pre class="haskell: ghci"><code>ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; [&#39;a&#39;..&#39;z&#39;]
&quot;abcdefghijklmnopqrstuvwxyz&quot;
ghci&gt; [&#39;K&#39;..&#39;Z&#39;]
&quot;KLMNOPQRSTUVWXYZ&quot;</code></pre>
<p>Ranges are cool because you can also specify a step. What if we want
all even numbers between 1 and 20? Or every third number between 1 and
20?</p>
<pre class="haskell: ghci"><code>ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18]</code></pre>
<p>It’s simply a matter of separating the first two elements with a
comma and then specifying what the upper limit is. While pretty smart,
ranges with steps aren’t as smart as some people expect them to be. You
can’t do <code>[1,2,4,8,16..100]</code> and expect to get all the powers
of 2. Firstly because you can only specify one step. And secondly
because some sequences that aren’t arithmetic are ambiguous if given
only by a few of their first terms.</p>
<p>To make a list with all the numbers from 20 to 1, you can’t just do
<code>[20..1]</code>, you have to do <code>[20,19..1]</code>.</p>
<p>Watch out when using floating point numbers in ranges! Because they
are not completely precise (by definition), their use in ranges can
yield some pretty funky results.</p>
<pre class="haskell: ghci"><code>ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]</code></pre>
<p>My advice is not to use them in list ranges.</p>
<p>You can also use ranges to make infinite lists by just not specifying
an upper limit. Later we’ll go into more detail on infinite lists. For
now, let’s examine how you would get the first 24 multiples of 13. Sure,
you could do <code>[13,26..24*13]</code>. But there’s a better way:
<code>take 24 [13,26..]</code>. Because Haskell is lazy, it won’t try to
evaluate the infinite list immediately because it would never finish.
It’ll wait to see what you want to get out of that infinite lists. And
here it sees you just want the first 24 elements and it gladly
obliges.</p>
<p>A handful of functions that produce infinite lists:</p>
<p><code class="label function">cycle</code> takes a list and cycles it
into an infinite list. If you just try to display the result, it will go
on forever so you have to slice it off somewhere.</p>
<pre class="haskell: ghci"><code>ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle &quot;LOL &quot;)
&quot;LOL LOL LOL &quot;</code></pre>
<p><code class="label function">repeat</code> takes an element and
produces an infinite list of just that element. It’s like cycling a list
with only one element.</p>
<pre class="haskell: ghci"><code>ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]</code></pre>
<p>Although it’s simpler to just use the <code
class="label function">replicate</code> function if you want some number
of the same element in a list. <code>replicate 3 10</code> returns
<code>[10,10,10]</code>.</p>
<h2 id="im-a-list-comprehension">I’m a list comprehension</h2>
<p><img src="assets/images/starting-out/kermit.png" class="left"
width="180" height="156" alt="frog" /> If you’ve ever taken a course in
mathematics, you’ve probably run into <em>set comprehensions</em>.
They’re normally used for building more specific sets out of general
sets. A basic comprehension for a set that contains the first ten even
natural numbers is <img src="assets/images/starting-out/setnotation.png"
alt="set notation" />. The part before the pipe is called the output
function, <code>x</code> is the variable, <code>N</code> is the input
set and <code>x &lt;= 10</code> is the predicate. That means that the
set contains the doubles of all natural numbers that satisfy the
predicate.</p>
<p>If we wanted to write that in Haskell, we could do something like
<code>take 10 [2,4..]</code>. But what if we didn’t want doubles of the
first 10 natural numbers but some kind of more complex function applied
on them? We could use a list comprehension for that. List comprehensions
are very similar to set comprehensions. We’ll stick to getting the first
10 even numbers for now. The list comprehension we could use is
<code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> is drawn from
<code>[1..10]</code> and for every element in <code>[1..10]</code>
(which we have bound to <code>x</code>), we get that element, only
doubled. Here’s that comprehension in action.</p>
<pre class="haskell: ghci"><code>ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]</code></pre>
<p>As you can see, we get the desired results. Now let’s add a condition
(or a predicate) to that comprehension. Predicates go after the binding
parts and are separated from them by a comma. Let’s say we want only the
elements which, doubled, are greater than or equal to 12.</p>
<pre class="haskell: ghci"><code>ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]
[12,14,16,18,20]</code></pre>
<p>Cool, it works. How about if we wanted all numbers from 50 to 100
whose remainder when divided with the number 7 is 3? Easy.</p>
<pre class="haskell: ghci"><code>ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94]</code></pre>
<p>Success! Note that weeding out lists by predicates is also called
<strong>filtering</strong>. We took a list of numbers and we filtered
them by the predicate. Now for another example. Let’s say we want a
comprehension that replaces each odd number greater than 10 with
<code>"BANG!"</code> and each odd number that’s less than 10 with
<code>"BOOM!"</code>. If a number isn’t odd, we throw it out of our
list. For convenience, we’ll put that comprehension inside a function so
we can easily reuse it.</p>
<pre class="haskell: ghci"><code>boomBangs xs = [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x]</code></pre>
<p>The last part of the comprehension is the predicate. The function
<code>odd</code> returns <code>True</code> on an odd number and
<code>False</code> on an even one. The element is included in the list
only if all the predicates evaluate to <code>True</code>.</p>
<pre class="haskell: hs"><code>ghci&gt; boomBangs [7..13]
[&quot;BOOM!&quot;,&quot;BOOM!&quot;,&quot;BANG!&quot;,&quot;BANG!&quot;]</code></pre>
<p>We can include several predicates. If we wanted all numbers from 10
to 20 that are not 13, 15 or 19, we’d do:</p>
<pre class="haskell: ghci"><code>ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</code></pre>
<p>Not only can we have multiple predicates in list comprehensions (an
element must satisfy all the predicates to be included in the resulting
list), we can also draw from several lists. When drawing from several
lists, comprehensions produce all combinations of the given lists and
then join them by the output function we supply. A list produced by a
comprehension that draws from two lists of length 4 will have a length
of 16, provided we don’t filter them. If we have two lists,
<code>[2,5,10]</code> and <code>[8,10,11]</code> and we want to get the
products of all the possible combinations between numbers in those
lists, here’s what we’d do.</p>
<pre class="haskell: ghci"><code>ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110]</code></pre>
<p>As expected, the length of the new list is 9. What if we wanted all
possible products that are more than 50?</p>
<pre class="haskell: ghci"><code>ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110]</code></pre>
<p>How about a list comprehension that combines a list of adjectives and
a list of nouns … for epic hilarity.</p>
<pre class="haskell: ghci"><code>ghci&gt; nouns = [&quot;hobo&quot;,&quot;frog&quot;,&quot;pope&quot;]
ghci&gt; adjectives = [&quot;lazy&quot;,&quot;grouchy&quot;,&quot;scheming&quot;]
ghci&gt; [adjective ++ &quot; &quot; ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
[&quot;lazy hobo&quot;,&quot;lazy frog&quot;,&quot;lazy pope&quot;,&quot;grouchy hobo&quot;,&quot;grouchy frog&quot;,
&quot;grouchy pope&quot;,&quot;scheming hobo&quot;,&quot;scheming frog&quot;,&quot;scheming pope&quot;]</code></pre>
<p>I know! Let’s write our own version of <code>length</code>! We’ll
call it <code>length'</code>.</p>
<pre class="haskell: hs"><code>length&#39; xs = sum [1 | _ &lt;- xs]</code></pre>
<p><code>_</code> means that we don’t care what we’ll draw from the list
anyway so instead of writing a variable name that we’ll never use, we
just write <code>_</code>. This function replaces every element of a
list with <code>1</code> and then sums that up. This means that the
resulting sum will be the length of our list.</p>
<p>Just a friendly reminder: because strings are lists, we can use list
comprehensions to process and produce strings. Here’s a function that
takes a string and removes everything except uppercase letters from
it.</p>
<pre class="haskell: hs"><code>removeNonUppercase st = [ c | c &lt;- st, c `elem` [&#39;A&#39;..&#39;Z&#39;]]</code></pre>
<p>Testing it out:</p>
<pre class="haskell: ghci"><code>ghci&gt; removeNonUppercase &quot;Hahaha! Ahahaha!&quot;
&quot;HA&quot;
ghci&gt; removeNonUppercase &quot;IdontLIKEFROGS&quot;
&quot;ILIKEFROGS&quot;</code></pre>
<p>The predicate here does all the work. It says that the character will
be included in the new list only if it’s an element of the list
<code>['A'..'Z']</code>. Nested list comprehensions are also possible if
you’re operating on lists that contain lists. A list contains several
lists of numbers. Let’s remove all odd numbers without flattening the
list.</p>
<pre class="haskell: ghci"><code>ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]</code></pre>
<p>You can write list comprehensions across several lines. So if you’re
not in GHCI, it’s better to split longer list comprehensions across
multiple lines, especially if they’re nested.</p>
<h2 id="tuples">Tuples</h2>
<p><img src="assets/images/starting-out/tuple.png" class="right"
width="160" height="162" alt="tuples" /></p>
<p>In some ways, tuples are like lists — they are a way to store several
values into a single value. However, there are a few fundamental
differences. A list of numbers is a list of numbers. That’s its type and
it doesn’t matter if it has only one number in it or an infinite amount
of numbers. Tuples, however, are used when you know exactly how many
values you want to combine and its type depends on how many components
it has and the types of the components. They are denoted with
parentheses and their components are separated by commas.</p>
<p>Another key difference is that they don’t have to be homogenous.
Unlike a list, a tuple can contain a combination of several types.</p>
<p>Think about how we’d represent a two-dimensional vector in Haskell.
One way would be to use a list. That would kind of work. So what if we
wanted to put a couple of vectors in a list to represent points of a
shape on a two-dimensional plane? We could do something like
<code>[[1,2],[8,11],[4,5]]</code>. The problem with that method is that
we could also do stuff like <code>[[1,2],[8,11,5],[4,5]]</code>, which
Haskell has no problem with since it’s still a list of lists with
numbers, but it kind of doesn’t make sense. But a tuple of size two
(also called a pair) is its own type, which means that a list can’t have
a couple of pairs in it and then a triple (a tuple of size three), so
let’s use that instead. Instead of surrounding the vectors with square
brackets, we use parentheses: <code>[(1,2),(8,11),(4,5)]</code>. What if
we tried to make a shape like <code>[(1,2),(8,11,5),(4,5)]</code>? Well,
we’d get this error:</p>
<pre class="haskell: ghci"><code>&lt;interactive&gt;:1:8: error: [GHC-83865]
    • Couldn&#39;t match expected type: (a, b)
                  with actual type: (a0, b0, c0)
    • In the expression: (8, 11, 5)
      In the expression: [(1, 2), (8, 11, 5), (4, 5)]
      In an equation for ‘it’: it = [(1, 2), (8, 11, 5), (4, 5)]
    • Relevant bindings include
        it :: [(a, b)] (bound at &lt;interactive&gt;:1:1)</code></pre>
<p>It’s telling us that we tried to use a pair and a triple in the same
list, which is not supposed to happen. You also couldn’t make a list
like <code>[(1,2),("One",2)]</code> because the first element of the
list is a pair of numbers and the second element is a pair consisting of
a string and a number. Tuples can also be used to represent a wide
variety of data. For instance, if we wanted to represent someone’s name
and age in Haskell, we could use a triple:
<code>("Christopher", "Walken", 55)</code>. As seen in this example,
tuples can also contain lists.</p>
<p>Use tuples when you know in advance how many components some piece of
data should have. Tuples are much more rigid because each different size
of tuple is its own type, so you can’t write a general function to
append an element to a tuple — you’d have to write a function for
appending to a pair, one function for appending to a triple, one
function for appending to a 4-tuple, etc.</p>
<p>While there are singleton lists, there’s no such thing as a singleton
tuple. It doesn’t really make much sense when you think about it. A
singleton tuple would just be the value it contains and as such would
have no benefit to us.</p>
<p>Like lists, tuples can be compared with each other if their
components can be compared. Only you can’t compare two tuples of
different sizes, whereas you can compare two lists of different sizes.
Two useful functions that operate on pairs:</p>
<p><code class="label function">fst</code> takes a pair and returns its
first component.</p>
<pre class="haskell: ghci"><code>ghci&gt; fst (8,11)
8
ghci&gt; fst (&quot;Wow&quot;, False)
&quot;Wow&quot;</code></pre>
<p><code class="label function">snd</code> takes a pair and returns its
second component. Surprise!</p>
<pre class="haskell: ghci"><code>ghci&gt; snd (8,11)
11
ghci&gt; snd (&quot;Wow&quot;, False)
False</code></pre>
<div class="hintbox">
<p><strong>Note:</strong> these functions operate only on pairs. They
won’t work on triples, 4-tuples, 5-tuples, etc. We’ll go over extracting
data from tuples in different ways a bit later.</p>
</div>
<p>A cool function that produces a list of pairs: <code
class="label function">zip</code>. It takes two lists and then zips them
together into one list by joining the matching elements into pairs. It’s
a really simple function but it has loads of uses. It’s especially
useful for when you want to combine two lists in a way or traverse two
lists simultaneously. Here’s a demonstration.</p>
<pre class="haskell: ghci"><code>ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 .. 5] [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
[(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]</code></pre>
<p>It pairs up the elements and produces a new list. The first element
goes with the first, the second with the second, etc. Notice that
because pairs can have different types in them, <code>zip</code> can
take two lists that contain different types and zip them up. What
happens if the lengths of the lists don’t match?</p>
<pre class="haskell: ghci"><code>ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] [&quot;im&quot;,&quot;a&quot;,&quot;turtle&quot;]
[(5,&quot;im&quot;),(3,&quot;a&quot;),(2,&quot;turtle&quot;)]</code></pre>
<p>The longer list simply gets cut off to match the length of the
shorter one. Because Haskell is lazy, we can zip finite lists with
infinite lists:</p>
<pre class="haskell: ghci"><code>ghci&gt; zip [1..] [&quot;apple&quot;, &quot;orange&quot;, &quot;cherry&quot;, &quot;mango&quot;]
[(1,&quot;apple&quot;),(2,&quot;orange&quot;),(3,&quot;cherry&quot;),(4,&quot;mango&quot;)]</code></pre>
<p><img src="assets/images/starting-out/pythag.png" class="center"
width="350" height="315" alt="look at meee" /></p>
<p>Here’s a problem that combines tuples and list comprehensions: which
right triangle that has integers for all sides and all sides equal to or
smaller than 10 has a perimeter of 24? First, let’s try generating all
triangles with sides equal to or smaller than 10:</p>
<pre class="haskell: ghci"><code>ghci&gt; triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ]</code></pre>
<p>We’re just drawing from three lists and our output function is
combining them into a triple. If you evaluate that by typing out
<code>triangles</code> in GHCI, you’ll get a list of all possible
triangles with sides under or equal to 10. Next, we’ll add a condition
that they all have to be right triangles. We’ll also modify this
function by taking into consideration that side b isn’t larger than the
hypothenuse and that side a isn’t larger than side b.</p>
<pre class="haskell: ghci"><code>ghci&gt; rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2]</code></pre>
<p>We’re almost done. Now, we just modify the function by saying that we
want the ones where the perimeter is 24.</p>
<pre class="haskell: ghci"><code>ghci&gt; rightTriangles&#39; = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles&#39;
[(6,8,10)]</code></pre>
<p>And there’s our answer! This is a common pattern in functional
programming. You take a starting set of solutions and then you apply
transformations to those solutions and filter them until you get the
right ones.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction.html" class="prevlink">Introduction</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters.html">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses.html" class="nxtlink">Types and Typeclasses</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>
</html>
